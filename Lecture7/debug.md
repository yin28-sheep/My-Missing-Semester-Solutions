> ## 前提
>
> 这一章题目较多，耗费时间较长

## 做题过程及运行结果

### 一. 调试
#### 1. 使用 Linux 上的 journalctl 或 macOS 上的 log show 命令来获取最近一天中超级用户的登录信息及其所执行的指令。如果找不到相关信息，您可以执行一些无害的命令，例如 sudo ls 然后再次查看。

![img1](./img/img一.1(1).png)

#### 2. 学习Pdb

> 1. 在你的终端运行如下的命令来克隆仓库:git clone https://github.com/spiside/pdb-tutorial
> 2. 现在你克隆好了仓库，让我们来到项目的根目录并看看里面的说明文件：cd /path/to/pdb-tutorial
> 3. 这看起来很容易！首先，让我们尝试玩这个游戏并看看哪里出了问题。你可以在你的终端输入如下的命令来运行这个程序：python main.py

![img2](./img/img一.2.1(1).png)

> 4. 看起来之前的程序员似乎有点...幽默感？尽管如此，让我们来输入 17（因为 17 是骰子的和）。奇怪。他说答案应该是 5，但显然不对...。好吧，也许骰子的加法是错误的，无论如何我们再玩一次游戏来弄清楚。看起来要再玩一次的命令是 Y，所以让我们输入 ,好吧，这很奇怪，即使我们输入了应该是有效的输入，程序仍然抛出了异常。我认为我们可以下结论说这个程序是有问题的，那么让我们开始调试程序吧！

![img2](./img/img一.2.1(2).png)

> 5. 是时候到了使用 python 自带的调试器 pdb 的时候了。这个调试器包含在 python 的标准库中，我们就像使用任何一个 python 库一样来使用它。首先，我们应先加载 pdb 模块，然后调用它的方法在程序中设置用于调试的程序断点。传统的方法是把加载和调用放在你想要程序暂停运行的地方。这个是你会用到的完整声明语句：import pdb; pdb.set_trace()。set_trace() 方法在被调用的地方设置了一个程序断点。让我们来打开 main.py 文件并在第 8 行添加程序断点：file: main.py,

![img2](./img/img一.2.2(1).png)

> 6. 看起来不错，现在让我们再次尝试运行 main.py 文件并看看会怎么样。

![img2](./img/img一.2.2(2打开pdb).png)

> 7. 5个会让你“说不出话来”的 pdb 命令

1. l(ist) 又叫做： 我懒得打开包含源代码的文件,现在让我们尝试使用l命令。在你已经打开的 pdb 调试窗口中，输入l并查看输出：如果我们想看整个文件，我们可以给 list 命令加上范围参数（1～13），像这样：

![img2](./img/img一.2.(3L).png)

2. s(tep) 又叫做： 让我们来看看这个方法做了什么...  你的程序现在应该还停留在 :9 行，要知道当前在哪一行可以查看 list 命令输出的 -> 箭头指向哪。让我们来调用 step 命令看看会发生什么。不错！我们目前在 runner.py 文件的第 21 行，这一点可以从 > /Users/Development/pdb-tutorial/dicegame/runner.py(21)run() 看出来。问题是，我们没有太多的上下文信息，所以让我们来运行 list 命令来检查这个方法。哇哦！现在我们有了 run() 方法的更多上下文信息。但我们现在还在 :21 行。让我们再次执行 step 命令来进入到这个方法内部，然后用 list 命令查看我们当前的位置。

![img2](./img/img一.2.2(3).png)

正如我们所看到的，我们正处于一个糟糕的变量名 c 上，如果我们尝试调用它将会产生很大的问题（回忆之前我们关于 c(ontinue) 命令的讨论）。

3. n(ext) 又叫做： 我希望当前的行不要抛出异常,在当前行输入 n(ext) 命令，然后输入 list（注意这个模式），然后让我们看看发生了什么。因为之前直接跳到了 runner = cls() 这一行，所以在这里我只要调用 2 次 next 就到了 for 语句,如果你继续输入 next 命令，你会遍历完这个 for 循环，遍历的长度等于 runner.dice 的长度。我们可以在 pdb 中用 len 方法来看看 runner.dice 的长度，应该会返回 5。

![img2](./img/img一.2.2(4).png)

4. b(reak) 又叫做：我再也不想输入 n 命令了,在这篇教程中，我们只需要看 b(reak) 命令描述的前两段。就像我在前面的部分提到的，我们想要通过设置程序断点的方式来执行完 for 循环，然后接着看 run() 方法的其他部分。因为 :34 行有 input 函数，程序会暂停并等待用户输入，所以让我们停在 :34 行。为了做到这一点，我们可以输入 b 34 然后输入 continue 来运行到程序断点处。我们也可以通过不带参数调用 break 命令来看看我们设置好的程序断点。如果要删除你的程序断点，你可以使用 cl(ear) 命令，参数是上面输出的程序断点行的最左边（也就是 1）。现在让我们调用参数为 1 的 clear 命令来删除刚才设置的程序断点。
> 注意：如果你没有提供任何参数给 clear 命令，那么就会清空所有的程序断点。  
> 现在我们可以调用 next 命令来执行 input() 函数。让我们猜测骰子和为 10 并输入我们的猜测，一旦我们回到 pdb 中，我们可以调用 list 命令来看看接下来的几行。  
> 记住我们是在尝试找出第一次玩游戏的时候我们猜测的骰子和不对的原因。这看起来似乎是 guess == runner.answer 这里的等于判断出了问题。我们应该仔细检查一下看看 runner.answer() 这个方法做了什么，以防万一可能会遇到错误。调用一次 next 命令然后调用 step 命令来进入到 runner.answer() 方法内部。  
> 我想我找到了问题根源！在第 18 行，它在计算 total 的时候看起来不是我们想象的那种骰子的加法。让我们来检查一下 die 有没有什么属性等于骰子本身的值看能不能解决这个问题。如果要到第 18 行，你可以通过设置一个程序断点，也可以一直调用 next 命令直到你到了循环到第一次迭代。一旦你到了 :18 行，让我们对 die 实例调用一下 dir() 函数看看它有什么属性和方法。  
> 它有一个属性叫做 value！让我们调用一下它看看返回了什么（注意，你这里显示的值可能跟我的不同）。同时让我们也调用一下它的 show() 方法显示骰子图案，确保显示的结果和它的 value 值一样。  
> 注意：如果你想要换行符 \n 真的有换行的效果，你可以执行 print(die.show())。

![img2](./img/img一.2.2(5)1.png)

![img2](./img/img一.2.2(5)2.png)

5.  r(eturn) 又叫做：我想退出这个函数,return 是一个强大的用户命令，让你可以直接检查函数的最后返回的结果。尽管你可以在调用 return 的地方设置一个程序断点，但如果一个函数里有多个 return 语句的话，还是在 pdb 里面使用 return 命令会好一些，因为它对一个 return 语句只会遵循一条执行路径。让我们调用一下 return 命令到函数的末尾。

![img2](./img/img一.2.2(6).png)

6. 高阶 pdb
这里有一些你可以使用的高阶的 pdb 命令。  
1. ! 命令  是在告诉 pdb 接下来的语句是 Python 命令而不是 pdb 命令。在带有变量名为 c 的 run() 方法中这很有用。就像我在教程一开始说的，直接在 pdb 里面输入 c 会被认为是要执行 continue 指令。进入 pdb 调试模式，停在 runner.py 的 :26 行，然后可以运行 !c 看看会发生什么。

![img2](./img/img一.2.2(7).png)

2. pdb Post Mortem   尽管这两个方法可能看上去一样，但是 post_mortem() 和 pm() 产生的异常信息轨迹不一样。我通常在 except 的代码块里面使用 post_mortem()。但是，我也会谈到 pm()，因为我发现它更强大。让我们来尝试这个方法并看看在实践中它是怎么工作的。先打开终端并进入到项目的根目录下，然后输入 python 进 python REPL 交互模式。然后，让我们从 main 模块里面载入 main 方法，同时要载入 pdb。接下来玩游戏直到我们在尝试输入 Y 继续游戏的时候抛出异常。现在，让我们从 pdb 模块中调用 pm() 方法看看会发生什么。

![img2](./img/img一.2.2(8).png)


#### 3. 安装 shellcheck 并尝试对下面的脚本进行检查。这段代码有什么问题吗？请修复相关问题。在您的编辑器中安装一个 linter 插件，这样它就可以自动地显示相关警告信息。

![img3](./img/img一.3(1).png)

> 在 Vim 中可以通过 neomake 插件来集成 shellcheck，在 ~/.vimrc 中添加 ` Plug ‘neomake/neomake’`

![img3](./img/img一.3(2).png)


### 二. 性能分析
#### 1. 下载了所提供的python代码和一系列的插件

1. 按照执行时间排序

![img1](./img/img二.1(1).png)

> 使用 line_profiler 进行分析，需要安装：pip install line_profiler
> 然后为需要分析的函数添加装饰器 @profile，并执行：kernprof -l -v sorts.py  
2. 首先对快速排序进行分析：

![img1](./img/img二.1(3快速).png)

3. 然后对插入排序进行分析：

![img1](./img/img二.1(3插入).png)

> 插入排序的耗时更高一些。快速排序的瓶颈在于 left 和 right 的赋值，而插入排序的瓶颈在 while 循环。  
> 使用 memory_profiler 进行分析，需要安装：pip install memory_profiler

4. 同样需要添加 @profile 装饰器。 首先分析快速排序的内存使用情况：

![img1](./img/img二.1(4快速).png)

5. 然后分析插入排序的内存使用情况：

![img1](./img/img二.1(4插入).png)

6. 同时对比原地操作的快速排序算法内存情况：

![img1](./img/img二.1(4原地操作).png)

> 我并未完成“使用 perf 检查每个算法的循环次数、缓存命中和丢失“这一步，所以未截屏

#### 2. 这里有一些用于计算斐波那契数列 Python 代码，它为计算每个数字都定义了一个函数：

![img2](./img/img二.2(1).png)

> 将代码拷贝到文件中使其变为一个可执行的程序。首先安装 pycallgraph 和 graphviz(如果您能够执行 dot, 则说明已经安装了 GraphViz.)。并使用 pycallgraph graphviz -- ./fib.py 来执行代码并查看 pycallgraph.png 这个文件。fib0 被调用了多少次？我们可以通过记忆法来对其进行优化。将注释掉的部分放开，然后重新生成图片。这回每个 fibN 函数被调用了多少次？

![img2](./img/img二.2(2).png)

#### 3. 我们经常会遇到的情况是某个我们希望去监听的端口已经被其他进程占用了。让我们通过进程的 PID 查找相应的进程。首先执行 python -m http.server 4444 启动一个最简单的 web 服务器来监听 4444 端口。

![img3](./img/img二.3(1).png)

> 在另外一个终端中，执行 lsof | grep LISTEN 打印出所有监听端口的进程及相应的端口。找到对应的 PID 然后使用 kill <PID> 停止该进程。

![img3](./img/img二.3(2).png)

#### 4. 限制进程资源也是一个非常有用的技术。执行 stress -c 3 并使用 htop 对 CPU 消耗进行可视化。现在，执行 taskset --cpu-list 0,2 stress -c 3 并可视化。stress 占用了 3 个 CPU 吗

![img4](./img/img二.4(1).png)


> 剩下的就不会了。。。。。